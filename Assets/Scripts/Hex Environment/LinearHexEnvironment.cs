using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using Sirenix.OdinInspector;

public class LinearHexEnvironment : MonoBehaviour
{
    [TabGroup("Grid", "üó∫Ô∏è Grid Setup")]
    [TitleGroup("Grid/Basic Grid Settings")]
    [SerializeField, Range(1, 20), Tooltip("Number of hex rings around the center hex")]
    private int gridRadius = 5;
    
    [TabGroup("Grid", "üó∫Ô∏è Grid Setup")]
    [TitleGroup("Grid/Basic Grid Settings")]
    [SerializeField, Range(0.1f, 10f), Tooltip("Size of each hexagon")]
    private float hexSize = 1f;
    
    [TabGroup("Grid", "üó∫Ô∏è Grid Setup")]
    [TitleGroup("Grid/Basic Grid Settings")]
    [SerializeField, Range(0f, 0.5f), Tooltip("Gap between hexagons (0 = touching)")]
    private float hexSpacing = 0.05f;
    
    [TabGroup("Linear", "üõ§Ô∏è Linear Lane Generation")]
    [TitleGroup("Linear/Basic Settings")]
    [SerializeField, Range(1, 6), Tooltip("Number of lanes to generate")]
    private int numberOfLanes = 3;
    
    [TabGroup("Linear", "üõ§Ô∏è Linear Lane Generation")]
    [TitleGroup("Linear/Basic Settings")]
    [SerializeField, Tooltip("Seed for deterministic generation (0 = random)")]
    private int generationSeed = 0;
    
    [TabGroup("Linear", "üõ§Ô∏è Linear Lane Generation")]
    [TitleGroup("Linear/Basic Settings")]
    [SerializeField, Range(1, 2), Tooltip("Size of center hub (1 = single hex, 2 = center + 6 surrounding = 7 total)")]
    private int centerHubSize = 2;
    
    [TabGroup("Linear", "üõ§Ô∏è Linear Lane Generation")]
    [TitleGroup("Linear/Expansion Settings")]
    [SerializeField, Range(0f, 3f), Tooltip("Multiplier for lane expansion strength (0 = no expansion, 3 = maximum expansion)")]
    private float expansionMultiplier = 1.0f;
    
    [TabGroup("Linear", "üõ§Ô∏è Linear Lane Generation")]
    [TitleGroup("Linear/Expansion Settings")]
    [SerializeField, Range(1, 10), Tooltip("Number of expansion iterations to perform")]
    private int expansionIterations = 3;
    
    [TabGroup("Linear", "üõ§Ô∏è Linear Lane Generation")]
    [TitleGroup("Linear/Expansion Settings")]
    [SerializeField, Range(0f, 1f), Tooltip("Probability of expanding into adjacent empty space per iteration")]
    private float expansionProbability = 0.6f;
    
    [TabGroup("Linear", "üõ§Ô∏è Linear Lane Generation")]
    [TitleGroup("Linear/Expansion Settings")]
    [SerializeField, Range(1f, 3f), Tooltip("Prefer expansion towards center (1 = no preference, 3 = strong center bias)")]
    private float centerBias = 1.5f;
    
    [TabGroup("Linear", "üõ§Ô∏è Linear Lane Generation")]
    [TitleGroup("Linear/Validation Settings")]
    [SerializeField, Range(3, 20), Tooltip("Maximum attempts to regenerate if validation fails")]
    private int maxValidationAttempts = 10;
    
    [TabGroup("Linear", "üõ§Ô∏è Linear Lane Generation")]
    [TitleGroup("Linear/Validation Settings")]
    [SerializeField, Tooltip("Automatically validate environment during generation")]
    private bool enableValidation = true;
    
    [TabGroup("Linear", "üõ§Ô∏è Linear Lane Generation")]
    [TitleGroup("Linear/Gameplay Features")]
    [SerializeField, Tooltip("Automatically generate defender spots adjacent to pathways")]
    private bool autoGenerateDefenderSpots = true;
    
    [TabGroup("Linear", "üõ§Ô∏è Linear Lane Generation")]
    [TitleGroup("Linear/Gameplay Features")]
    [SerializeField, Tooltip("Generate one spawn point per lane at the outermost hex")]
    private bool generateEdgeSpawns = true;
    
    [TabGroup("Linear", "üõ§Ô∏è Linear Lane Generation")]
    [TitleGroup("Linear/Gameplay Features")]
    [SerializeField, Tooltip("Generate only gizmos without instantiating GameObjects")]
    private bool gizmosOnlyMode = false;
    
    [TabGroup("Linear", "üõ§Ô∏è Linear Lane Generation")]
    [TitleGroup("Linear/Generation Actions")]
    [Button(ButtonSizes.Large, Name = "üöÄ Generate Linear Environment")]
    [GUIColor(0.4f, 0.8f, 0.4f)]
    private void GenerateButtonPressed()
    {
        GenerateLinearEnvironment();
    }
    
    [TabGroup("Linear", "üõ§Ô∏è Linear Lane Generation")]
    [TitleGroup("Linear/Generation Actions")]
    [Button(ButtonSizes.Medium, Name = "üé≤ Randomize Seed")]
    [GUIColor(0.8f, 0.8f, 0.4f)]
    private void RandomizeButtonPressed()
    {
        RandomizeSeed();
    }
    
    [TabGroup("Linear", "üõ§Ô∏è Linear Lane Generation")]
    [TitleGroup("Linear/Generation Actions")]
    [Button(ButtonSizes.Medium, Name = "üóëÔ∏è Clear Environment")]
    [GUIColor(0.8f, 0.4f, 0.4f)]
    private void ClearButtonPressed()
    {
        ClearExistingHexes();
    }
    
    [TabGroup("Prefabs", "üéÆ Prefabs")]
    [TitleGroup("Prefabs/Required Prefabs")]
    [SerializeField, Tooltip("Default hexagon prefab (optional - leave null for gizmos only)")]
    private GameObject hexPrefab;
    
    [TabGroup("Prefabs", "üéÆ Prefabs")]
    [TitleGroup("Prefabs/Optional Overrides")]
    [SerializeField, Tooltip("Center hub prefab (optional)")]
    private GameObject centerHubPrefab;
    
    [TabGroup("Prefabs", "üéÆ Prefabs")]
    [TitleGroup("Prefabs/Optional Overrides")]
    [SerializeField, Tooltip("Pathway prefab (optional)")]
    private GameObject pathwayPrefab;
    
    [TabGroup("Prefabs", "üéÆ Prefabs")]
    [TitleGroup("Prefabs/Optional Overrides")]
    [SerializeField, Tooltip("Defender spot prefab (optional)")]
    private GameObject defenderSpotPrefab;
    
    [TabGroup("Prefabs", "üéÆ Prefabs")]
    [TitleGroup("Prefabs/Optional Overrides")]
    [SerializeField, Tooltip("Edge spawn prefab (optional)")]
    private GameObject edgeSpawnPrefab;
    
    [TabGroup("Prefabs", "üéÆ Prefabs")]
    [TitleGroup("Prefabs/Hierarchy Settings")]
    [SerializeField, Tooltip("Optional parent transform for spawned hexagons")]
    private Transform hexParent;
    
    [TabGroup("Prefabs", "üéÆ Prefabs")]
    [TitleGroup("Prefabs/Generation Settings")]
    [SerializeField, Tooltip("Generate environment automatically on Start")]
    private bool generateOnStart = true;
    
    [TabGroup("Debug", "üîß Debug & Visualization")]
    [TitleGroup("Debug/Gizmo Display Settings")]
    [SerializeField, Tooltip("Show gizmos for hex positions")]
    private bool showGizmos = true;
    
    [TabGroup("Debug", "üîß Debug & Visualization")]
    [TitleGroup("Debug/Gizmo Display Settings")]
    [SerializeField, Tooltip("Show hex type labels in scene view")]
    private bool showTypeLabels = true;
    
    [TabGroup("Debug", "üîß Debug & Visualization")]
    [TitleGroup("Debug/Gizmo Display Settings")]
    [SerializeField, Tooltip("Show filled gizmos instead of wireframe")]
    private bool showFilledGizmos = false;
    
    [TabGroup("Debug", "üîß Debug & Visualization")]
    [TitleGroup("Debug/Gizmo Display Settings")]
    [SerializeField, Tooltip("Show lane connections between hexes")]
    private bool showLaneConnections = true;
    
    [TabGroup("Debug", "üîß Debug & Visualization")]
    [TitleGroup("Debug/Gizmo Display Settings")]
    [SerializeField, Tooltip("Gizmo transparency"), Range(0.1f, 1f)]
    private float gizmoAlpha = 0.7f;
    
    [TabGroup("Debug", "üîß Debug & Visualization")]
    [TitleGroup("Debug/Hex Type Visibility")]
    [SerializeField, Tooltip("Show center hub hexes")]
    private bool showCenterHub = true;
    
    [TabGroup("Debug", "üîß Debug & Visualization")]
    [TitleGroup("Debug/Hex Type Visibility")]
    [SerializeField, Tooltip("Show pathway hexes")]
    private bool showPathways = true;
    
    [TabGroup("Debug", "üîß Debug & Visualization")]
    [TitleGroup("Debug/Hex Type Visibility")]
    [SerializeField, Tooltip("Show defender spot hexes")]
    private bool showDefenderSpots = true;
    
    [TabGroup("Debug", "üîß Debug & Visualization")]
    [TitleGroup("Debug/Hex Type Visibility")]
    [SerializeField, Tooltip("Show edge spawn hexes")]
    private bool showEdgeSpawns = true;
    
    [TabGroup("Debug", "üîß Debug & Visualization")]
    [TitleGroup("Debug/Hex Type Visibility")]
    [SerializeField, Tooltip("Show environment hexes")]
    private bool showEnvironment = false;
    
    [TabGroup("Debug", "üîß Debug & Visualization")]
    [TitleGroup("Debug/Hex Colors")]
    [SerializeField, Tooltip("Color for center hub")]
    private Color centerHubColor = new Color(0.2f, 1f, 0.2f, 1f);
    
    [TabGroup("Debug", "üîß Debug & Visualization")]
    [TitleGroup("Debug/Hex Colors")]
    [SerializeField, Tooltip("Color for defender spots")]
    private Color defenderSpotColor = new Color(1f, 0.3f, 0.3f, 1f);
    
    [TabGroup("Debug", "üîß Debug & Visualization")]
    [TitleGroup("Debug/Hex Colors")]
    [SerializeField, Tooltip("Color for edge spawn points")]
    private Color edgeSpawnColor = new Color(0.3f, 0.6f, 1f, 1f);
    
    [TabGroup("Debug", "üîß Debug & Visualization")]
    [TitleGroup("Debug/Hex Colors")]
    [SerializeField, Tooltip("Color for pathway connections")]
    private Color pathwayConnectionColor = new Color(1f, 0.8f, 0.2f, 1f);
    
    [TabGroup("Debug", "üîß Debug & Visualization")]
    [TitleGroup("Debug/Hex Colors")]
    [SerializeField, Tooltip("Color for environment hexes")]
    private Color environmentColor = new Color(0.7f, 0.7f, 0.7f, 1f);
    
    [TabGroup("Debug", "üîß Debug & Visualization")]
    [TitleGroup("Debug/Advanced Options")]
    [SerializeField, Tooltip("Show hex coordinates")]
    private bool showCoordinates = false;
    
    [TabGroup("Debug", "üîß Debug & Visualization")]
    [TitleGroup("Debug/Advanced Options")]
    [SerializeField, Tooltip("Show only specific lane (0-5, -1 = all)"), Range(-1, 5)]
    private int showOnlyLane = -1;
    
    // Runtime data
    private Dictionary<HexCoordinates, HexData> hexGrid = new Dictionary<HexCoordinates, HexData>();
    private List<HexCoordinates> generatedCoordinates = new List<HexCoordinates>();
    private List<List<HexCoordinates>> generatedLanes = new List<List<HexCoordinates>>();
    private List<HexCoordinates> laneSpawnPoints = new List<HexCoordinates>();
    
    // Hex math constants
    private readonly float SQRT_3 = Mathf.Sqrt(3f);
    
    // Hex direction vectors
    private readonly HexCoordinates[] HEX_DIRECTIONS = {
        new HexCoordinates(1, 0),   // E
        new HexCoordinates(0, 1),   // NE
        new HexCoordinates(-1, 1),  // NW
        new HexCoordinates(-1, 0),  // W
        new HexCoordinates(0, -1),  // SW
        new HexCoordinates(1, -1)   // SE
    };
    
    #region Unity Events
    
    private void Start()
    {
        if (generateOnStart)
        {
            GenerateLinearEnvironment();
        }
    }
    
    #endregion
    
    #region Public Methods
    
    public void GenerateLinearEnvironment()
    {
        ClearExistingHexes();
        
        // Initialize random seed
        if (generationSeed == 0)
        {
            generationSeed = Random.Range(1, int.MaxValue);
        }
        Random.InitState(generationSeed);
        
        // Check if we can instantiate objects
        bool canInstantiateObjects = !gizmosOnlyMode && hexPrefab != null;
        
        if (!canInstantiateObjects)
        {
            Debug.Log($"[LinearHexEnvironment] Running in gizmos-only mode. {(gizmosOnlyMode ? "Gizmos-only mode enabled." : "Hex prefab is null.")}");
        }
        
        // Setup parent if needed
        if (canInstantiateObjects && hexParent == null)
        {
            GameObject parentGO = new GameObject("Linear Hex Grid");
            parentGO.transform.SetParent(transform);
            hexParent = parentGO.transform;
        }
        
        // Generate with validation
        bool success = false;
        int attempts = 0;
        
        while (!success && attempts < maxValidationAttempts)
        {
            attempts++;
            
            // Step 1: Generate all hex coordinates
            GenerateAllHexCoordinates();
            
            // Step 2: Generate direct lanes from edge to center
            GenerateDirectLanes();
            
            // Step 3: Expand lanes iteratively
            ExpandLanes();
            
            // Step 4: Generate defender spots and edge spawns
            if (autoGenerateDefenderSpots)
            {
                GenerateDefenderSpots();
            }
            
            if (generateEdgeSpawns)
            {
                GenerateEdgeSpawnPoints();
            }
            
            // Step 5: Validate
            if (enableValidation)
            {
                success = ValidateEnvironment();
                if (!success)
                {
                    Debug.LogWarning($"[LinearHexEnvironment] Validation failed on attempt {attempts}. Retrying...");
                    ClearLaneData();
                }
            }
            else
            {
                success = true;
            }
        }
        
        if (!success)
        {
            Debug.LogError($"[LinearHexEnvironment] Failed to generate valid environment after {maxValidationAttempts} attempts.");
        }
        else
        {
            Debug.Log($"[LinearHexEnvironment] Successfully generated environment {(attempts > 1 ? $"after {attempts} attempts" : "on first attempt")}.");
        }
        
        // Step 6: Instantiate objects if possible
        if (canInstantiateObjects)
        {
            InstantiateHexGameObjects();
        }
    }
    
    public void RandomizeSeed()
    {
        generationSeed = Random.Range(1, int.MaxValue);
        Debug.Log($"[LinearHexEnvironment] New seed: {generationSeed}");
    }
    
    public void ClearExistingHexes()
    {
        if (hexParent != null)
        {
            // Clear existing children
            for (int i = hexParent.childCount - 1; i >= 0; i--)
            {
                if (Application.isPlaying)
                {
                    Destroy(hexParent.GetChild(i).gameObject);
                }
                else
                {
                    DestroyImmediate(hexParent.GetChild(i).gameObject);
                }
            }
        }
        
        hexGrid.Clear();
        generatedCoordinates.Clear();
        generatedLanes.Clear();
        laneSpawnPoints.Clear();
        
        Debug.Log("[LinearHexEnvironment] Cleared existing hexes.");
    }
    
    public HexData GetHexAt(HexCoordinates coord)
    {
        hexGrid.TryGetValue(coord, out HexData hex);
        return hex;
    }
    
    public GameObject GetHexGameObjectAt(HexCoordinates coord)
    {
        var hex = GetHexAt(coord);
        return hex?.gameObject;
    }
    
    public List<HexData> GetHexesOfType(HexType type)
    {
        return hexGrid.Values.Where(hex => hex.type == type).ToList();
    }
    
    public List<HexData> GetLaneHexes(int laneId)
    {
        return hexGrid.Values.Where(hex => hex.laneId == laneId).ToList();
    }
    
    public HexCoordinates WorldToHex(Vector3 worldPosition)
    {
        // Convert world position to hex coordinates
        float x = worldPosition.x / (hexSize + hexSpacing);
        float z = worldPosition.z / (hexSize + hexSpacing);
        
        float q = (SQRT_3/3f * x - 1f/3f * z);
        float r = (2f/3f * z);
        
        return CubeToHex(CubeRound(q, -q-r, r));
    }
    
    #endregion
    
    #region Generation Methods
    
    private void GenerateAllHexCoordinates()
    {
        generatedCoordinates.Clear();
        hexGrid.Clear();
        
        // Generate all coordinates in a hex grid pattern
        for (int q = -gridRadius; q <= gridRadius; q++)
        {
            int r1 = Mathf.Max(-gridRadius, -q - gridRadius);
            int r2 = Mathf.Min(gridRadius, -q + gridRadius);
            
            for (int r = r1; r <= r2; r++)
            {
                HexCoordinates coord = new HexCoordinates(q, r);
                generatedCoordinates.Add(coord);
                
                // Determine initial type
                HexType type = IsPartOfCenterHub(coord) ? HexType.CenterHub : HexType.Environment;
                HexData hexData = new HexData(coord, type);
                hexGrid[coord] = hexData;
            }
        }
        
        Debug.Log($"[LinearHexEnvironment] Generated {generatedCoordinates.Count} hex coordinates.");
    }
    
    private void GenerateDirectLanes()
    {
        generatedLanes.Clear();
        laneSpawnPoints.Clear();
        
        // Find evenly spaced edge positions for lane starts
        List<HexCoordinates> edgeHexes = GetEdgeHexes();
        List<HexCoordinates> startingPositions = FindSpacedEdgeStartingPositions(edgeHexes);
        
        Debug.Log($"[LinearHexEnvironment] Generating {startingPositions.Count} direct lanes.");
        
        for (int i = 0; i < startingPositions.Count && i < numberOfLanes; i++)
        {
            HexCoordinates start = startingPositions[i];
            List<HexCoordinates> directPath = FindDirectPathToCenter(start);
            
            if (directPath.Count > 0)
            {
                generatedLanes.Add(directPath);
                laneSpawnPoints.Add(start);
                
                // Mark hexes as pathway
                foreach (var hex in directPath)
                {
                    if (hexGrid.ContainsKey(hex) && !IsPartOfCenterHub(hex))
                    {
                        hexGrid[hex].type = HexType.Pathway;
                        hexGrid[hex].laneId = i;
                    }
                }
                
                Debug.Log($"[LinearHexEnvironment] Generated direct lane {i} with {directPath.Count} hexes.");
            }
        }
    }
    
    private void ExpandLanes()
    {
        if (expansionMultiplier <= 0f || expansionIterations <= 0)
        {
            Debug.Log("[LinearHexEnvironment] Skipping lane expansion (multiplier or iterations = 0).");
            return;
        }
        
        Debug.Log($"[LinearHexEnvironment] Expanding lanes over {expansionIterations} iterations with multiplier {expansionMultiplier}.");
        
        for (int iteration = 0; iteration < expansionIterations; iteration++)
        {
            List<List<HexCoordinates>> newLaneAdditions = new List<List<HexCoordinates>>();
            
            // For each lane, find potential expansion hexes
            for (int laneId = 0; laneId < generatedLanes.Count; laneId++)
            {
                List<HexCoordinates> expansions = FindLaneExpansions(laneId, iteration);
                newLaneAdditions.Add(expansions);
            }
            
            // Apply expansions simultaneously
            for (int laneId = 0; laneId < newLaneAdditions.Count; laneId++)
            {
                foreach (var newHex in newLaneAdditions[laneId])
                {
                    if (hexGrid.ContainsKey(newHex) && hexGrid[newHex].type == HexType.Environment)
                    {
                        hexGrid[newHex].type = HexType.Pathway;
                        hexGrid[newHex].laneId = laneId;
                        generatedLanes[laneId].Add(newHex);
                    }
                }
                
                if (newLaneAdditions[laneId].Count > 0)
                {
                    Debug.Log($"[LinearHexEnvironment] Iteration {iteration + 1}: Expanded lane {laneId} by {newLaneAdditions[laneId].Count} hexes.");
                }
            }
        }
    }
    
    private List<HexCoordinates> FindLaneExpansions(int laneId, int iteration)
    {
        List<HexCoordinates> currentLane = generatedLanes[laneId];
        List<HexCoordinates> expansions = new List<HexCoordinates>();
        HashSet<HexCoordinates> checkedHexes = new HashSet<HexCoordinates>();
        
        // Check each hex in the current lane for expansion opportunities
        foreach (var laneHex in currentLane)
        {
            foreach (var direction in HEX_DIRECTIONS)
            {
                HexCoordinates candidate = new HexCoordinates(laneHex.q + direction.q, laneHex.r + direction.r);
                
                if (checkedHexes.Contains(candidate) || !hexGrid.ContainsKey(candidate))
                    continue;
                
                checkedHexes.Add(candidate);
                
                // Check if this hex can be expanded into
                if (CanExpandIntoHex(candidate, laneId, iteration))
                {
                    expansions.Add(candidate);
                }
            }
        }
        
        return expansions;
    }
    
    private bool CanExpandIntoHex(HexCoordinates hex, int laneId, int iteration)
    {
        // Must be environment type (empty)
        if (!hexGrid.ContainsKey(hex) || hexGrid[hex].type != HexType.Environment)
            return false;
        
        // Calculate expansion probability based on various factors
        float probability = expansionProbability * expansionMultiplier;
        
        // Reduce probability with each iteration
        probability *= Mathf.Pow(0.8f, iteration);
        
        // Apply center bias - prefer expanding towards center
        float distanceToCenter = HexDistance(hex, HexCoordinates.Zero);
        float currentLaneDistance = GetAverageDistanceToCenter(laneId);
        
        if (distanceToCenter < currentLaneDistance)
        {
            probability *= centerBias;
        }
        else if (distanceToCenter > currentLaneDistance + 1)
        {
            probability *= 0.5f; // Reduce probability for expanding away from center
        }
        
        // Check for clumping prevention
        int adjacentPathways = CountAdjacentPathways(hex);
        if (adjacentPathways > 2)
        {
            probability *= 0.3f; // Heavily reduce clumping
        }
        
        // Ensure defender accessibility will be maintained
        if (!WillMaintainDefenderAccess(hex))
        {
            return false;
        }
        
        return Random.value < probability;
    }
    
    private float GetAverageDistanceToCenter(int laneId)
    {
        if (laneId >= generatedLanes.Count || generatedLanes[laneId].Count == 0)
            return 0f;
        
        float totalDistance = 0f;
        foreach (var hex in generatedLanes[laneId])
        {
            totalDistance += HexDistance(hex, HexCoordinates.Zero);
        }
        
        return totalDistance / generatedLanes[laneId].Count;
    }
    
    private int CountAdjacentPathways(HexCoordinates hex)
    {
        int count = 0;
        foreach (var direction in HEX_DIRECTIONS)
        {
            HexCoordinates adjacent = new HexCoordinates(hex.q + direction.q, hex.r + direction.r);
            if (hexGrid.ContainsKey(adjacent) && hexGrid[adjacent].type == HexType.Pathway)
            {
                count++;
            }
        }
        return count;
    }
    
    private bool WillMaintainDefenderAccess(HexCoordinates hex)
    {
        // Check if adding this hex would create a pathway hex without adjacent defender access
        int adjacentPathwayCount = CountAdjacentPathways(hex);
        int adjacentEnvironmentCount = CountAdjacentEnvironment(hex);
        
        // If this hex would be surrounded by pathways with no environment space for defenders, reject it
        return adjacentEnvironmentCount > 0 || adjacentPathwayCount < 3;
    }
    
    private int CountAdjacentEnvironment(HexCoordinates hex)
    {
        int count = 0;
        foreach (var direction in HEX_DIRECTIONS)
        {
            HexCoordinates adjacent = new HexCoordinates(hex.q + direction.q, hex.r + direction.r);
            if (hexGrid.ContainsKey(adjacent) && hexGrid[adjacent].type == HexType.Environment)
            {
                count++;
            }
        }
        return count;
    }
    
    #endregion
    
    #region Helper Methods
    
    private List<HexCoordinates> GetEdgeHexes()
    {
        return generatedCoordinates.Where(coord => HexDistance(coord, HexCoordinates.Zero) >= gridRadius - 0.5f).ToList();
    }
    
    private List<HexCoordinates> FindSpacedEdgeStartingPositions(List<HexCoordinates> edgeHexes)
    {
        List<HexCoordinates> startingPositions = new List<HexCoordinates>();
        
        if (numberOfLanes <= 0 || edgeHexes.Count == 0)
            return startingPositions;
        
        // Sort edge hexes by angle around the center
        edgeHexes.Sort((a, b) => {
            Vector3 posA = HexToWorldPosition(a);
            Vector3 posB = HexToWorldPosition(b);
            float angleA = Mathf.Atan2(posA.z, posA.x);
            float angleB = Mathf.Atan2(posB.z, posB.x);
            return angleA.CompareTo(angleB);
        });
        
        // Select evenly spaced positions
        float step = (float)edgeHexes.Count / numberOfLanes;
        for (int i = 0; i < numberOfLanes; i++)
        {
            int index = Mathf.RoundToInt(i * step) % edgeHexes.Count;
            startingPositions.Add(edgeHexes[index]);
        }
        
        return startingPositions;
    }
    
    private List<HexCoordinates> FindDirectPathToCenter(HexCoordinates start)
    {
        List<HexCoordinates> path = new List<HexCoordinates>();
        HexCoordinates current = start;
        HashSet<HexCoordinates> visited = new HashSet<HexCoordinates>();
        
        path.Add(current);
        visited.Add(current);
        
        while (!IsPartOfCenterHub(current) && visited.Count < gridRadius * 2)
        {
            HexCoordinates next = GetClosestUnvisitedHexToCenter(current, visited);
            
            if (next == current) // No valid next hex found
                break;
            
            current = next;
            path.Add(current);
            visited.Add(current);
        }
        
        return path;
    }
    
    private HexCoordinates GetClosestUnvisitedHexToCenter(HexCoordinates from, HashSet<HexCoordinates> visited)
    {
        HexCoordinates best = from;
        float bestDistance = HexDistance(from, HexCoordinates.Zero);
        
        foreach (var direction in HEX_DIRECTIONS)
        {
            HexCoordinates candidate = new HexCoordinates(from.q + direction.q, from.r + direction.r);
            
            if (!hexGrid.ContainsKey(candidate) || visited.Contains(candidate))
                continue;
            
            float distance = HexDistance(candidate, HexCoordinates.Zero);
            if (distance < bestDistance)
            {
                best = candidate;
                bestDistance = distance;
            }
        }
        
        return best;
    }
    
    private bool IsPartOfCenterHub(HexCoordinates coord)
    {
        if (coord.Equals(HexCoordinates.Zero))
            return true;
        
        if (centerHubSize >= 2)
        {
            return HexDistance(coord, HexCoordinates.Zero) < 1.5f;
        }
        
        return false;
    }
    
    private float HexDistance(HexCoordinates a, HexCoordinates b)
    {
        return (Mathf.Abs(a.q - b.q) + Mathf.Abs(a.q + a.r - b.q - b.r) + Mathf.Abs(a.r - b.r)) / 2f;
    }
    
    private void ClearLaneData()
    {
        // Reset all hexes to environment except center hub
        foreach (var kvp in hexGrid.ToList())
        {
            if (!IsPartOfCenterHub(kvp.Key))
            {
                hexGrid[kvp.Key].type = HexType.Environment;
                hexGrid[kvp.Key].laneId = -1;
            }
        }
        
        generatedLanes.Clear();
        laneSpawnPoints.Clear();
    }
    
    #endregion
    
    #region Validation
    
    private bool ValidateEnvironment()
    {
        if (!ValidateAllLanesReachCenter())
        {
            Debug.LogWarning("[LinearHexEnvironment] Validation failed: Not all lanes reach center.");
            return false;
        }
        
        if (!ValidateDefenderAccessibility())
        {
            Debug.LogWarning("[LinearHexEnvironment] Validation failed: Insufficient defender accessibility.");
            return false;
        }
        
        if (!ValidateNoClumping())
        {
            Debug.LogWarning("[LinearHexEnvironment] Validation failed: Pathway clumping detected.");
            return false;
        }
        
        return true;
    }
    
    private bool ValidateAllLanesReachCenter()
    {
        foreach (var lane in generatedLanes)
        {
            bool reachesCenter = lane.Any(hex => IsPartOfCenterHub(hex));
            if (!reachesCenter)
            {
                return false;
            }
        }
        return true;
    }
    
    private bool ValidateDefenderAccessibility()
    {
        foreach (var kvp in hexGrid)
        {
            if (kvp.Value.type == HexType.Pathway)
            {
                if (!HasAdjacentDefenderSpots(kvp.Key))
                {
                    return false;
                }
            }
        }
        return true;
    }
    
    private bool ValidateNoClumping()
    {
        foreach (var kvp in hexGrid)
        {
            if (kvp.Value.type == HexType.Pathway)
            {
                int adjacentPathways = CountAdjacentPathways(kvp.Key);
                if (adjacentPathways > 3) // Allow some clustering but prevent excessive clumping
                {
                    return false;
                }
            }
        }
        return true;
    }
    
    private bool HasAdjacentDefenderSpots(HexCoordinates hex)
    {
        foreach (var direction in HEX_DIRECTIONS)
        {
            HexCoordinates adjacent = new HexCoordinates(hex.q + direction.q, hex.r + direction.r);
            if (hexGrid.ContainsKey(adjacent))
            {
                HexType type = hexGrid[adjacent].type;
                if (type == HexType.Environment || type == HexType.DefenderSpot)
                {
                    return true;
                }
            }
        }
        return false;
    }
    
    #endregion
    
    #region Feature Generation
    
    private void GenerateDefenderSpots()
    {
        List<HexCoordinates> defenderSpots = new List<HexCoordinates>();
        
        foreach (var kvp in hexGrid.ToList())
        {
            if (kvp.Value.type == HexType.Environment)
            {
                // Check if this environment hex is adjacent to a pathway
                bool adjacentToPathway = false;
                foreach (var direction in HEX_DIRECTIONS)
                {
                    HexCoordinates adjacent = new HexCoordinates(kvp.Key.q + direction.q, kvp.Key.r + direction.r);
                    if (hexGrid.ContainsKey(adjacent) && hexGrid[adjacent].type == HexType.Pathway)
                    {
                        adjacentToPathway = true;
                        break;
                    }
                }
                
                if (adjacentToPathway)
                {
                    hexGrid[kvp.Key].type = HexType.DefenderSpot;
                    defenderSpots.Add(kvp.Key);
                }
            }
        }
        
        Debug.Log($"[LinearHexEnvironment] Generated {defenderSpots.Count} defender spots.");
    }
    
    private void GenerateEdgeSpawnPoints()
    {
        foreach (var spawnPoint in laneSpawnPoints)
        {
            if (hexGrid.ContainsKey(spawnPoint))
            {
                hexGrid[spawnPoint].type = HexType.EdgeSpawn;
            }
        }
        
        Debug.Log($"[LinearHexEnvironment] Generated {laneSpawnPoints.Count} edge spawn points.");
    }
    
    private void InstantiateHexGameObjects()
    {
        if (hexPrefab == null)
        {
            Debug.LogWarning("[LinearHexEnvironment] Cannot instantiate objects: hexPrefab is null.");
            return;
        }
        
        int instantiated = 0;
        
        foreach (var kvp in hexGrid)
        {
            Vector3 worldPos = HexToWorldPosition(kvp.Key);
            GameObject prefab = GetPrefabForHexType(kvp.Value.type);
            
            if (prefab != null)
            {
                GameObject instance = Instantiate(prefab, worldPos, Quaternion.identity, hexParent);
                instance.name = $"Hex_{kvp.Value.type}_{kvp.Key}";
                kvp.Value.gameObject = instance;
                instantiated++;
            }
        }
        
        Debug.Log($"[LinearHexEnvironment] Instantiated {instantiated} hex GameObjects.");
    }
    
    private GameObject GetPrefabForHexType(HexType type)
    {
        switch (type)
        {
            case HexType.CenterHub:
                return centerHubPrefab ?? hexPrefab;
            case HexType.Pathway:
                return pathwayPrefab ?? hexPrefab;
            case HexType.DefenderSpot:
                return defenderSpotPrefab ?? hexPrefab;
            case HexType.EdgeSpawn:
                return edgeSpawnPrefab ?? hexPrefab;
            default:
                return hexPrefab;
        }
    }
    
    #endregion
    
    #region Coordinate Math
    
    private Vector3 HexToWorldPosition(HexCoordinates hex)
    {
        float x = (hex.q + hex.r * 0.5f) * (hexSize + hexSpacing) * SQRT_3;
        float z = hex.r * (hexSize + hexSpacing) * 1.5f;
        return new Vector3(x, 0f, z);
    }
    
    private HexCoordinates CubeToHex(Vector3 cube)
    {
        return new HexCoordinates(Mathf.RoundToInt(cube.x), Mathf.RoundToInt(cube.z));
    }
    
    private Vector3 CubeRound(float x, float y, float z)
    {
        int rx = Mathf.RoundToInt(x);
        int ry = Mathf.RoundToInt(y);
        int rz = Mathf.RoundToInt(z);
        
        float x_diff = Mathf.Abs(rx - x);
        float y_diff = Mathf.Abs(ry - y);
        float z_diff = Mathf.Abs(rz - z);
        
        if (x_diff > y_diff && x_diff > z_diff)
            rx = -ry - rz;
        else if (y_diff > z_diff)
            ry = -rx - rz;
        else
            rz = -rx - ry;
        
        return new Vector3(rx, ry, rz);
    }
    
    #endregion
    
    #region Gizmos
    
    private void OnDrawGizmos()
    {
        if (!showGizmos || hexGrid.Count == 0)
            return;
        
        // Draw hex gizmos
        foreach (var kvp in hexGrid)
        {
            if (ShouldShowHexType(kvp.Value.type, kvp.Value.laneId))
            {
                Vector3 center = HexToWorldPosition(kvp.Key);
                DrawEnhancedHexGizmo(center, hexSize, kvp.Value.type, kvp.Value.laneId);
                
                if (showTypeLabels)
                {
                    #if UNITY_EDITOR
                    UnityEditor.Handles.Label(center + Vector3.up * 0.5f, GetHexTypeLabel(kvp.Value.type, kvp.Value.laneId));
                    #endif
                }
                
                if (showCoordinates)
                {
                    #if UNITY_EDITOR
                    UnityEditor.Handles.Label(center + Vector3.up * 0.2f, kvp.Key.ToString());
                    #endif
                }
            }
        }
        
        // Draw lane connections
        if (showLaneConnections && showPathways)
        {
            DrawLaneConnections();
        }
    }
    
    private bool ShouldShowHexType(HexType type, int laneId)
    {
        if (showOnlyLane >= 0 && type == HexType.Pathway && laneId != showOnlyLane)
            return false;
        
        switch (type)
        {
            case HexType.CenterHub: return showCenterHub;
            case HexType.Pathway: return showPathways;
            case HexType.DefenderSpot: return showDefenderSpots;
            case HexType.EdgeSpawn: return showEdgeSpawns;
            case HexType.Environment: return showEnvironment;
            default: return true;
        }
    }
    
    private void DrawLaneConnections()
    {
        Gizmos.color = pathwayConnectionColor;
        
        foreach (var lane in generatedLanes)
        {
            for (int i = 0; i < lane.Count - 1; i++)
            {
                Vector3 from = HexToWorldPosition(lane[i]);
                Vector3 to = HexToWorldPosition(lane[i + 1]);
                Gizmos.DrawLine(from + Vector3.up * 0.1f, to + Vector3.up * 0.1f);
            }
        }
    }
    
    private Color GetEnhancedColorForHexType(HexType type, int laneId = -1)
    {
        Color baseColor;
        
        switch (type)
        {
            case HexType.CenterHub:
                baseColor = centerHubColor;
                break;
            case HexType.Pathway:
                baseColor = GetLaneColor(laneId);
                break;
            case HexType.DefenderSpot:
                baseColor = defenderSpotColor;
                break;
            case HexType.EdgeSpawn:
                baseColor = edgeSpawnColor;
                break;
            default:
                baseColor = environmentColor;
                break;
        }
        
        baseColor.a = gizmoAlpha;
        return baseColor;
    }
    
    private Color GetLaneColor(int laneId)
    {
        if (laneId >= 0 && laneId < numberOfLanes)
        {
            return Color.HSVToRGB((float)laneId / numberOfLanes, 0.8f, 1f);
        }
        return pathwayConnectionColor;
    }
    
    private string GetHexTypeLabel(HexType type, int laneId)
    {
        switch (type)
        {
            case HexType.CenterHub: return "üè†";
            case HexType.Pathway: return $"üõ§Ô∏è{laneId}";
            case HexType.DefenderSpot: return "üõ°Ô∏è";
            case HexType.EdgeSpawn: return "üö™";
            default: return "üåø";
        }
    }
    
    private void DrawEnhancedHexGizmo(Vector3 center, float size, HexType type, int laneId)
    {
        Color color = GetEnhancedColorForHexType(type, laneId);
        Gizmos.color = color;
        
        Vector3[] corners = new Vector3[6];
        for (int i = 0; i < 6; i++)
        {
            float angle = i * 60f * Mathf.Deg2Rad;
            corners[i] = center + new Vector3(Mathf.Cos(angle) * size * 0.5f, 0f, Mathf.Sin(angle) * size * 0.5f);
        }
        
        if (showFilledGizmos)
        {
            DrawSolidFilledHex(corners, center, color);
        }
        else
        {
            DrawHexOutline(corners, type, color);
        }
        
        DrawTypeSpecificMarkers(center, size, type, laneId, color);
    }
    
    private void DrawSolidFilledHex(Vector3[] corners, Vector3 center, Color solidColor)
    {
        #if UNITY_EDITOR
        UnityEditor.Handles.color = solidColor;
        UnityEditor.Handles.DrawAAConvexPolygon(corners);
        #else
        // Fallback for runtime
        for (int i = 0; i < 6; i++)
        {
            Gizmos.DrawLine(corners[i], corners[(i + 1) % 6]);
        }
        #endif
    }
    
    private void DrawHexOutline(Vector3[] corners, HexType type, Color solidColor)
    {
        for (int i = 0; i < 6; i++)
        {
            Gizmos.DrawLine(corners[i], corners[(i + 1) % 6]);
        }
    }
    
    private void DrawTypeSpecificMarkers(Vector3 center, float size, HexType type, int laneId, Color solidColor)
    {
        switch (type)
        {
            case HexType.CenterHub:
                Gizmos.DrawWireSphere(center + Vector3.up * 0.1f, size * 0.2f);
                break;
                
            case HexType.DefenderSpot:
                DrawShieldSymbol(center, size * 0.3f, solidColor);
                break;
                
            case HexType.EdgeSpawn:
                #if UNITY_EDITOR
                UnityEditor.Handles.color = solidColor;
                UnityEditor.Handles.DrawWireArc(center, Vector3.up, Vector3.forward, 360f, size * 0.3f);
                #endif
                Gizmos.DrawWireSphere(center + Vector3.up * 0.2f, size * 0.1f);
                break;
        }
    }
    
    private void DrawShieldSymbol(Vector3 center, float size, Color color = default)
    {
        if (color != default(Color))
            Gizmos.color = color;
        
        Vector3 top = center + Vector3.forward * size + Vector3.up * 0.1f;
        Vector3 left = center + Vector3.left * size * 0.7f + Vector3.up * 0.1f;
        Vector3 right = center + Vector3.right * size * 0.7f + Vector3.up * 0.1f;
        Vector3 bottom = center + Vector3.back * size * 0.5f + Vector3.up * 0.1f;
        
        Gizmos.DrawLine(top, left);
        Gizmos.DrawLine(left, bottom);
        Gizmos.DrawLine(bottom, right);
        Gizmos.DrawLine(right, top);
    }
    
    #endregion
}
